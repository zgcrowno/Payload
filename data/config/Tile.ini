;TILE

[O-Tile]
Group = tile
Graphic = G-Tile
Body = B-Tile
Position = @Commands.CalculatePosition
ShaderList = SH-Tile
;User-Defined
Pos = (0, 0)
Depth = O-Tile

[G-Tile]
Texture = tile.png
Pivot = center

; Using bodies/body parts purely for debugging purposes at this point.
[B-Tile]
Dynamic = true
PartList = BP-Tile

[BP-Tile]
Type = box
Solid = false

[SH-Tile]
ParamList = texture # 
			Cartesian #
			LeftEdgeTopPoint # 
			LeftEdgeBottomPoint # 
			RightEdgeTopPoint # 
			RightEdgeBottomPoint #
			TopRadius #
			BottomRadius #
			BorderThickness
Cartesian = 0
LeftEdgeTopPoint = (0.0, 0.0)  
LeftEdgeBottomPoint = (0.0, 0.0)    
RightEdgeTopPoint = (0.0, 0.0)  
RightEdgeBottomPoint = (0.0, 0.0)  
TopRadius = 0.0
BottomRadius = 0.0
BorderThickness = 0.002
UseCustomParam = true
Code = "

void main()
{
	// The currently concerned pixel of the texture on which this shader is acting.
	vec2 curPix = gl_TexCoord[0].xy;
	// The coordinates for the center of the tile set.
	vec2 center = vec2(0.5, 0.5);
	// The distance from curPix to center.
	float centerDistance = length(center.xy - curPix);
	// If leftEdgeDifference > 0, curPix is to the right of the left edge; if < 0, curPix is to the left of the left edge; if == 0, curPix is on the left edge.
	float leftEdgeDifference = (curPix.x - LeftEdgeTopPoint.x) * 
		(LeftEdgeBottomPoint.y - LeftEdgeTopPoint.y) - 
		(curPix.y - LeftEdgeTopPoint.y) * 
		(LeftEdgeBottomPoint.x - LeftEdgeTopPoint.x);
	// If rightEdgeDifference > 0, curPix is to the right of the right edge; if < 0, curPix is to the left of the right edge; if == 0, curPix is on the right edge.
	float rightEdgeDifference = (curPix.x - RightEdgeTopPoint.x) * 
		(RightEdgeBottomPoint.y - RightEdgeTopPoint.y) - 
		(curPix.y - RightEdgeTopPoint.y) * 
		(RightEdgeBottomPoint.x - RightEdgeTopPoint.x);
	// If topEdgeDifference > 0, curPix is above the top edge; if < 0, curPix is below the top edge; if == 0, curPix is on the top edge.
	float topEdgeDifference = (curPix.x - LeftEdgeTopPoint.x) * 
		(RightEdgeTopPoint.y - LeftEdgeTopPoint.y) - 
		(curPix.y - LeftEdgeTopPoint.y) * 
		(RightEdgeTopPoint.x - LeftEdgeTopPoint.x);
	// If bottomEdgeDifference > 0, curPix is above the bottom edge; if < 0, curPix is below the bottom edge; if == 0, curPix is on the bottom edge.
	float bottomEdgeDifference = (curPix.x - LeftEdgeBottomPoint.x) * 
		(RightEdgeBottomPoint.y - LeftEdgeBottomPoint.y) - 
		(curPix.y - LeftEdgeBottomPoint.y) * 
		(RightEdgeBottomPoint.x - LeftEdgeBottomPoint.x);
	// The distance from curPix to the left edge.
	float leftEdgeDistance = abs(
								 (LeftEdgeBottomPoint.y - LeftEdgeTopPoint.y) * curPix.x - 
								 (LeftEdgeBottomPoint.x - LeftEdgeTopPoint.x) * curPix.y + 
								 LeftEdgeBottomPoint.x * LeftEdgeTopPoint.y - LeftEdgeBottomPoint.y * LeftEdgeTopPoint.x) / 
							 sqrt(
								  pow(LeftEdgeBottomPoint.y - LeftEdgeTopPoint.y, 2) + 
								  pow(LeftEdgeBottomPoint.x - LeftEdgeTopPoint.x, 2));
	// The distance from curPix to the right edge.
	float rightEdgeDistance = abs(
								  (RightEdgeBottomPoint.y - RightEdgeTopPoint.y) * curPix.x - 
								  (RightEdgeBottomPoint.x - RightEdgeTopPoint.x) * curPix.y + 
								  RightEdgeBottomPoint.x * RightEdgeTopPoint.y - RightEdgeBottomPoint.y * RightEdgeTopPoint.x) / 
							  sqrt(
								   pow(RightEdgeBottomPoint.y - RightEdgeTopPoint.y, 2) + 
								   pow(RightEdgeBottomPoint.x - RightEdgeTopPoint.x, 2));
	// The distance from curPix to the top edge.
	float topEdgeDistance = abs(
								(RightEdgeTopPoint.y - LeftEdgeTopPoint.y) * curPix.x - 
								(RightEdgeTopPoint.x - LeftEdgeTopPoint.x) * curPix.y + 
								RightEdgeTopPoint.x * LeftEdgeTopPoint.y - RightEdgeTopPoint.y * LeftEdgeTopPoint.x) / 
							sqrt(
								 pow(LeftEdgeBottomPoint.y - LeftEdgeTopPoint.y, 2) + 
								 pow(LeftEdgeBottomPoint.x - LeftEdgeTopPoint.x, 2));
	// The distance from curPix to the bottom edge.
	float bottomEdgeDistance = abs(
								   (RightEdgeBottomPoint.y - LeftEdgeBottomPoint.y) * curPix.x - 
								   (RightEdgeBottomPoint.x - LeftEdgeBottomPoint.x) * curPix.y + 
								   RightEdgeBottomPoint.x * LeftEdgeBottomPoint.y - RightEdgeBottomPoint.y * LeftEdgeBottomPoint.x) / 
							   sqrt(
								    pow(RightEdgeBottomPoint.y - LeftEdgeBottomPoint.y, 2) + 
								    pow(RightEdgeBottomPoint.x - LeftEdgeBottomPoint.x, 2));
	
	if(Cartesian == 1)
	{
		if(leftEdgeDifference > 0 &&
		   rightEdgeDifference < 0 &&
		   topEdgeDifference < 0 &&
		   bottomEdgeDifference > 0 &&
		   leftEdgeDistance > BorderThickness &&
		   rightEdgeDistance > BorderThickness &&
		   topEdgeDistance > BorderThickness &&
		   bottomEdgeDistance > BorderThickness)
		{
			gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
		}
		else if(leftEdgeDifference > 0 &&
				rightEdgeDifference < 0 &&
				topEdgeDifference < 0 &&
				bottomEdgeDifference > 0)
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
		else
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		}
	}
	else
	{
		if(centerDistance < TopRadius - BorderThickness && 
		   centerDistance > BottomRadius + BorderThickness &&
		   leftEdgeDifference > 0 &&
		   rightEdgeDifference < 0 &&
		   leftEdgeDistance > BorderThickness &&
		   rightEdgeDistance > BorderThickness)
		{
			gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
		}
		else if(centerDistance < TopRadius && 
				centerDistance > BottomRadius &&
				leftEdgeDifference > 0 &&
				rightEdgeDifference < 0)
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
		else
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		}
	}
}"
