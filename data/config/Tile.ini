;TILE

[O-Tile]
Graphic = G-Tile
Body = B-Tile
ShaderList = SH-Tile

[G-Tile]
Texture = tile.png
Pivot = center

[B-Tile]
Dynamic = true
PartList = BP-Tile

[BP-Tile]
Type = box
Solid = false

[SH-Tile]
ParamList = texture # 
			UnitDistanceFromOrigin #
			TopCenterAngle #
			BottomCenterAngle #
			LeftEdgeTopAngle #
			LeftEdgeBottomAngle #
			RightEdgeTopAngle #
			RightEdgeBottomAngle #
			TopCenterPoint #
			BottomCenterPoint #
			LeftEdgeTopPoint # 
			LeftEdgeBottomPoint # 
			RightEdgeTopPoint # 
			RightEdgeBottomPoint #
			BorderThickness
UnitDistanceFromOrigin = 0
TopCenterAngle = 0.0
BottomCenterAngle = 0.0
LeftEdgeTopAngle = 0.0
LeftEdgeBottomAngle = 0.0
RightEdgeTopAngle = 0.0
RightEdgeBottomAngle = 0.0
TopCenterPoint = (0.0, 0.0)
BottomCenterPoint = (0.0, 0.0)
LeftEdgeTopPoint = (0.0, 0.0)  
LeftEdgeBottomPoint = (0.0, 0.0)    
RightEdgeTopPoint = (0.0, 0.0)  
RightEdgeBottomPoint = (0.0, 0.0)  
BorderThickness = 0.01
UseCustomParam = true
Code = "

void main()
{
	vec2 curPix = gl_TexCoord[0].xy;
	vec2 topTriangleCircumcenter = vec2(
		(LeftEdgeTopPoint.x * sin(2.0f * LeftEdgeTopAngle) + RightEdgeTopPoint.x * sin(2.0f * RightEdgeTopAngle) + TopCenterPoint.x * sin(2.0f * TopCenterAngle)) 
		/ (sin(2.0f * LeftEdgeTopAngle) + sin(2.0f * RightEdgeTopAngle) + sin(2.0f * TopCenterAngle)),
        (LeftEdgeTopPoint.y * sin(2.0f * LeftEdgeTopAngle) + RightEdgeTopPoint.y * sin(2.0f * RightEdgeTopAngle) + TopCenterPoint.y * sin(2.0f * TopCenterAngle)) 
		/ (sin(2.0f * LeftEdgeTopAngle) + sin(2.0f * RightEdgeTopAngle) + sin(2.0f * TopCenterAngle)));
	vec2 bottomTriangleCircumcenter = vec2(
		(LeftEdgeBottomPoint.x * sin(2.0f * LeftEdgeBottomAngle) + RightEdgeBottomPoint.x * sin(2.0f * RightEdgeBottomAngle) + BottomCenterPoint.x * sin(2.0f * BottomCenterAngle)) / (sin(2.0f * LeftEdgeBottomAngle) + sin(2.0f * RightEdgeBottomAngle) + sin(2.0f * BottomCenterAngle)),
        (LeftEdgeBottomPoint.y * sin(2.0f * LeftEdgeBottomAngle) + RightEdgeBottomPoint.y * sin(2.0f * RightEdgeBottomAngle) + BottomCenterPoint.y * sin(2.0f * BottomCenterAngle)) / (sin(2.0f * LeftEdgeBottomAngle) + sin(2.0f * RightEdgeBottomAngle) + sin(2.0f * BottomCenterAngle)));
	float topRadius = length(topTriangleCircumcenter.xy - TopCenterPoint.xy);
	float bottomRadius = UnitDistanceFromOrigin == 1 ? 0 : length(bottomTriangleCircumcenter.xy - BottomCenterPoint.xy);
	float topDist = length(topTriangleCircumcenter.xy - curPix);
	float bottomDist = length(bottomTriangleCircumcenter.xy - curPix);
	float leftEdgeDifference = (curPix.x - LeftEdgeTopPoint.x) * 
		(LeftEdgeBottomPoint.y - LeftEdgeTopPoint.y) - 
		(curPix.y - LeftEdgeTopPoint.y) * 
		(LeftEdgeBottomPoint.x - LeftEdgeTopPoint.x);
	float rightEdgeDifference = (curPix.x - RightEdgeTopPoint.x) * 
		(RightEdgeBottomPoint.y - RightEdgeTopPoint.y) - 
		(curPix.y - RightEdgeTopPoint.y) * 
		(RightEdgeBottomPoint.x - RightEdgeTopPoint.x);
	
	if(topDist < topRadius - BorderThickness && 
	   bottomDist > bottomRadius + BorderThickness &&
	   leftEdgeDifference - BorderThickness > 0 &&
	   rightEdgeDifference + BorderThickness < 0)
	{
		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
	}
	else if(topDist < topRadius && 
			bottomDist > bottomRadius &&
			leftEdgeDifference > 0 &&
			rightEdgeDifference < 0)
	{
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	else
	{
		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	}
}"

;TILE EDGE

[O-TileEdge]
Size = (1, 1, 1)
UseParentSpace = position
;User-Defined
FillAlpha = 1
FillColor = (0, 0, 0)
NumVertices = 10

[O-TileEdge1@O-TileEdge]

[O-TileEdge2@O-TileEdge]

[O-TileEdge3@O-TileEdge]

[O-TileEdge4@O-TileEdge]

;TILE EDGE VERTEX

[O-TileEdgeVertex@O-ScrollMod]
Size = (1, 1, 1)
UseParentSpace = position
