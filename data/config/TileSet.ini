;TILE SET

[O-TileSet]
Graphic = @
Texture = % > @, > Get < PNG, > @, > Get < Square, > @, > Get < TileSet, Return "<<<"
Pivot = center
;Size = (1, 1, 1)
Position = (0.2142857143, 0)
Scale = (0.5238095238, 0.9166666667)
ParentCamera = MainCamera
UseParentSpace = both
ShaderList = SH-TileSet
ChildList = O-PlayerPayload # O-Goal
;User-Defined
Square = 4 ; The number of rows and columns (in Cartesian space) the TileSet has. This value must always be even.
State = @E-TileSetState.Polar1D
TimeToShift = 0.5 ; The amount of time, in seconds, it will take for a coordinate or dimensional shift to complete.
PayloadOrigin = (0, 0) ; The row/column coordinates of the tile on which the PlayerPayload will be spawned.
GoalOrigin = (0, 2) ; The row/column coordinates of the tile on which the Goal will be spawned.
PNG = .png
TileSet = TileSet

[SH-TileSet]
ParamList = texture #
			Square #
			PriorState #
			ShiftStatus #
			D2 #
			Cartesian #
			TimeToShift #
			TimeSpentShifting #
			PayloadPosition #
			PriorPayloadPosition #
			; TileSetStates for readability
			StateCartesian1D #
			StateCartesian2D #
			StatePolar1D #
			StatePolar2D #
			; TileSetShiftStatuses for readability
			ShiftStatusNone #
			ShiftStatusD1 #
			ShiftStatusD2 #
			ShiftStatusCartesian #
			ShiftStatusPolar #
			ShiftStatusD1Tiles
Square = 0
PriorState = @E-TileSetState.Cartesian2D
ShiftStatus = @E-TileSetShiftStatus.None
D2 = 0
Cartesian = 0
TimeToShift = @O-TileSet.TimeToShift
TimeSpentShifting = @.TimeToShift
PayloadPosition = (0.0, 0.0)
PriorPayloadPosition = (0.0, 0.0)
; TileSetStates for readability
StateCartesian1D = @E-TileSetState.Cartesian1D
StateCartesian2D = @E-TileSetState.Cartesian2D
StatePolar1D = @E-TileSetState.Polar1D
StatePolar2D = @E-TileSetState.Polar2D
; TileSetShiftStatuses for readability
ShiftStatusNone = @E-TileSetShiftStatus.None
ShiftStatusD1 = @E-TileSetShiftStatus.D1
ShiftStatusD2 = @E-TileSetShiftStatus.D2
ShiftStatusCartesian = @E-TileSetShiftStatus.Cartesian
ShiftStatusPolar = @E-TileSetShiftStatus.Polar
ShiftStatusD1Tiles = @E-TileSetShiftStatus.D1Tiles
UseCustomParam = true
Code = "

#define PI 3.1415926535897932384626433832795
#define PI2 (2.0 * PI)
#define NATIVE_TEXTURE_SIZE 1024.0
#define NATIVE_BORDER_THICKNESS 5.0

vec2 square2circle(vec2 xy, float anim)
{
    // [...* 2.0 - 1.0] so the space will be from -1 to 1 instead of from 0 to 1.
	xy = xy * 2.0 - 1.0;
    float u;
    float v;
    float x2 = xy.x * xy.x;
    float y2 = xy.y * xy.y;
    if (x2 >= y2)
    {
		u = mix(sign(xy.x) * (x2 / sqrt(x2 + y2)), xy.x, anim);
		v = mix(sign(xy.x) * ((xy.x * xy.y) / sqrt(x2 + y2)), xy.y, anim);
    }
    else
    {
		u = mix(sign(xy.y) * ((xy.x * xy.y) / sqrt(x2 + y2)), xy.x, anim);
		v = mix(sign(xy.y) * (y2 / sqrt(x2 + y2)), xy.y, anim);
    }
    // [...* 0.5 + 0.5] to get us back into texture space (undoing [...* 2.0 - 1.0]).
    return vec2(u, v) * 0.5 + 0.5;
}

vec2 circle2square(vec2 xy, float anim)
{
	// [...* 2.0 - 1.0] so the space will be from -1 to 1 instead of from 0 to 1.
	xy = xy * 2.0 - 1.0;
    float u;
    float v;
    float x2 = xy.x * xy.x;
    float y2 = xy.y * xy.y;
    if (x2 >= y2)
    {
		u = mix(sign(xy.x) * sqrt(x2 + y2), xy.x, anim);
		v = mix(sign(xy.x) * (xy.y / xy.x) * sqrt(x2 + y2), xy.y, anim);
    }
    else
    {
		u = mix(sign(xy.y) * (xy.x / xy.y) * sqrt(x2 + y2), xy.x, anim);
		v = mix(sign(xy.y) * sqrt(x2 + y2), xy.y, anim);
    }
	// [...* 0.5 + 0.5] to get us back into texture space (undoing [...* 2.0 - 1.0]).
    return vec2(u, v) * 0.5 + 0.5;
}

// BEGIN ALERT: This function for performing a polar transformation on a passed texture 
// has both self-same and inverse counterparts in code. Ensure that any changes I make here are reflected
// code side.
// END ALERT
vec2 CartesianToPolar(vec2 uv, float anim)
{
	// Subtracting uv from (1., 1.) so we can place the polar axis on the bottom of the texture.
	uv = vec2(1.0, 1.0) - uv;
	
	// swap axis to move the line from the right side of the texture to the bottom.
    uv.xy = uv.yx;
	
	// Move uv to center of screen--delta's space is now [-1, 1] instead of [0, 1].
	vec2 delta = uv * 2.0 - 1.0;
	float radius = length(delta);
	float angle = (atan(delta.y, delta.x) + PI) / PI2;
	
	vec2 polarUV = vec2(radius, angle);
	
	float mixWeight = smoothstep(0.0, 1.0, anim);
	
	return mix(uv, polarUV, mixWeight);
}

void main()
{
	// The uv coordinates of the current pixel.
	vec2 uv = gl_TexCoord[0].xy;
	// lerp weight to mix between dimensions/coordinate systems.
	float anim;
	// The number of borders (either vertically or horizontally).
	int numBorders = int(Square) + 1;
	// The normalized size (thickness) of a border in the TileSet.
	float borderSize = NATIVE_BORDER_THICKNESS / NATIVE_TEXTURE_SIZE;
	// The normalized size (both width and height) of a tile in the TileSet.
	float tileSize = ((NATIVE_TEXTURE_SIZE - (numBorders * NATIVE_BORDER_THICKNESS)) / Square) / NATIVE_TEXTURE_SIZE;
	// Is the TileSet Cartesian?
	bool cartesian = Cartesian == 1;
	// Is the TileSet 2D?
	bool d2 = D2 == 1;
	
	if (cartesian)
	{
		if (d2)
		{
			if (PriorState == StatePolar2D) // Cartesian1D
			{
				anim = TimeSpentShifting / TimeToShift;
				anim = clamp(anim, 0.0, 1.0);
				uv = circle2square(uv, anim);
			}
		}
		else
		{
			if (PriorState == StatePolar1D) // Cartesian2D
			{
				if (ShiftStatus == ShiftStatusD1Tiles)
				{
					anim = 0.0;
				}
				else
				{
					anim = 1.0 - TimeSpentShifting / TimeToShift;
				}
				anim = clamp(anim, 0.0, 1.0);
				uv = CartesianToPolar(uv , anim);
			}
		}
	}
	else
	{
		if (d2)
		{
			anim = 1.0 - TimeSpentShifting / TimeToShift;
			anim = clamp(anim, 0.0, 1.0);
			
			if (PriorState == StateCartesian2D) // Cartesian2D
			{
				uv = circle2square(uv, anim);
			}
			else // statePolar1D
			{
				uv = circle2square(CartesianToPolar(uv , anim), anim);
			}
		}
		else
		{
			if (PriorState == StateCartesian1D) // Cartesian1D
			{
				if (ShiftStatus == ShiftStatusD1Tiles)
				{
					anim = 1.0;
				}
				else
				{
					anim = TimeSpentShifting / TimeToShift;
				}
				anim = clamp(anim, 0.0, 1.0);
				uv = CartesianToPolar(uv , anim);
			}
			else // statePolar2D
			{
				if (ShiftStatus == ShiftStatusD1Tiles)
				{
					anim = 1.0;
				}
				else
				{
					anim = TimeSpentShifting / TimeToShift;
				}
				anim = clamp(anim, 0.0, 1.0);
				uv = circle2square(CartesianToPolar(uv , anim), anim);
			}
		}
	}
	
	// The color of the texture at uv.
	vec4 col = texture2D(texture, uv);
	
	// Ensure that col is either pure white or pure black
	float whiteProximity = length(col - vec4(1.0, 1.0, 1.0, 1.0));
	float blackProximity = length(col - vec4(0.0, 0.0, 0.0, 1.0));
	if (whiteProximity > blackProximity)
	{
		col = vec4(0.0, 0.0, 0.0, 1.0);
	}
	else
	{
		col = vec4(1.0, 1.0, 1.0, 1.0);
	}
	
	// Change color of background tiles.
	if (!d2 && cartesian)
	{
		float uvY;
		float lerpWeight = ShiftStatus == ShiftStatusD1Tiles ? TimeSpentShifting / TimeToShift : ShiftStatus == ShiftStatusNone ? 1.0 : 0.0;
		float tileSetBottomY = 0.0;
		float tileSetTopY = 1.0;
		float payloadY = PayloadPosition.y;
		if (PriorState == StatePolar1D) // Polar1D.
		{
			uvY = 1.0 - uv.x;
		}
		else
		{
			uvY = uv.y;
		}
		float payloadTileTopY = payloadY + (tileSize / 2.0) + borderSize;
		float payloadTileBottomY = payloadY - (tileSize / 2.0) - borderSize;
		float distanceFromPayloadTileTopYToTileSetTopY = abs(payloadTileTopY - tileSetTopY);
		float distanceFromPayloadTileBottomYToTileSetBottomY = abs(payloadTileBottomY - tileSetBottomY);
		bool topDistGreater = distanceFromPayloadTileTopYToTileSetTopY > distanceFromPayloadTileBottomYToTileSetBottomY;
		float tileSetForegroundBottomYLerpWeight = topDistGreater ?
												   lerpWeight * (distanceFromPayloadTileTopYToTileSetTopY / distanceFromPayloadTileBottomYToTileSetBottomY) :
												   lerpWeight;
		float tileSetForegroundTopYLerpWeight = topDistGreater ? 
												lerpWeight : 
												lerpWeight * (distanceFromPayloadTileBottomYToTileSetBottomY / distanceFromPayloadTileTopYToTileSetTopY);
		float tileSetForegroundBottomY = mix(tileSetBottomY, payloadTileBottomY, tileSetForegroundBottomYLerpWeight);
		float tileSetForegroundTopY = mix(tileSetTopY, payloadTileTopY, tileSetForegroundTopYLerpWeight);
		bool uvInPayloadTile = uvY <= payloadTileTopY && uvY >= payloadTileBottomY;
		bool uvInForegroundDistanceBottom = uvY >= tileSetForegroundBottomY && uvY <= payloadTileBottomY;
		bool uvInForegroundDistanceTop = uvY <= tileSetForegroundTopY && uvY >= payloadTileTopY;
		bool uvInForeground = uvInPayloadTile || uvInForegroundDistanceTop || uvInForegroundDistanceBottom;
		if (!uvInForeground)
		{
			if (col.x == 0 && col.y == 0 && col.z == 0)
			{
				col = vec4(1.0, 1.0, 1.0, 1.0);
			}
			else if (col.x == 1 && col.y == 1 && col.z == 1)
			{
				col = vec4(0.0, 0.0, 0.0, 1.0);
			}
		}
	}
	else if (!d2)
	{
		vec2 payloadPolarPos = ShiftStatus == ShiftStatusNone ? CartesianToPolar(PriorPayloadPosition.xy, anim) : CartesianToPolar(PayloadPosition.xy, anim);
		float lerpWeight = ShiftStatus == ShiftStatusD1Tiles ? TimeSpentShifting / TimeToShift : ShiftStatus == ShiftStatusNone ? 1.0 : 0.0;
		float tileRadius = 0.5 / Square;
		float payloadTileInnerDist = length(payloadPolarPos.x - tileRadius);
		float payloadTileOuterDist = length(payloadPolarPos.x + tileRadius);
		
		
		
		float distanceFromPayloadTileInnerDistToTileSetCenter = length(payloadPolarPos.x - tileRadius);
		float distanceFromPayloadTileOuterDistToTileSetRadius = 1.0 - length(payloadPolarPos.x + tileRadius);
		bool outerDistGreater = distanceFromPayloadTileOuterDistToTileSetRadius > distanceFromPayloadTileInnerDistToTileSetCenter;
		float tileSetForegroundInnerDistLerpWeight = outerDistGreater ?
												   lerpWeight * (distanceFromPayloadTileOuterDistToTileSetRadius / distanceFromPayloadTileInnerDistToTileSetCenter) :
												   lerpWeight;
		float tileSetForegroundOuterDistLerpWeight = outerDistGreater ? 
												lerpWeight : 
												lerpWeight * (distanceFromPayloadTileInnerDistToTileSetCenter / distanceFromPayloadTileOuterDistToTileSetRadius);
		float tileSetForegroundInnerDist = mix(0.0, payloadTileInnerDist, tileSetForegroundInnerDistLerpWeight);
		float tileSetForegroundOuterDist = mix(1.0, payloadTileOuterDist, tileSetForegroundOuterDistLerpWeight);
		bool uvInPayloadTile = uv.x <= payloadTileOuterDist && uv.x >= payloadTileInnerDist;
		bool uvInForegroundDistanceInner = uv.x >= tileSetForegroundInnerDist && uv.x <= payloadTileInnerDist;
		bool uvInForegroundDistanceOuter = uv.x <= tileSetForegroundOuterDist && uv.x >= payloadTileOuterDist;
		bool uvInOuterTileSetEdge = uv.x <= borderSize || uv.x >= 1.0 - borderSize || uv.y <= borderSize || uv.y >= 1.0 - borderSize;
		bool uvInForeground = uvInPayloadTile || uvInForegroundDistanceInner || uvInForegroundDistanceOuter;
		
		
		if (!uvInForeground && !uvInOuterTileSetEdge)
		{
			if (col.x == 0 && col.y == 0 && col.z == 0)
			{
				col = vec4(1.0, 1.0, 1.0, 1.0);
			}
			else if (col.x == 1 && col.y == 1 && col.z == 1)
			{
				col = vec4(0.0, 0.0, 0.0, 1.0);
			}
		}
	}
	
	gl_FragColor = col;
}"

;This shader is not being used, but is kept because the behavior it fosters is something I may want to utilize at some point. See https://www.shadertoy.com/view/3dsSWs
[SH-TileSetTest]
ParamList = texture # 
			iTime #
			ShiftStatus #
			Cartesian #
			Square #
			TimeToShift #
			TimeSpentShifting #
			BorderThickness
iTime = time
ShiftStatus = @E-TileSetShiftStatus.None
Cartesian = 0
Square = 0    
TimeToShift = @O-TileSet.TimeToShift
TimeSpentShifting = @.TimeToShift
BorderThickness = 0.01
UseCustomParam = true
Code = "

#define IMPROVED 1           // make 0 for faster approach

float tileCartesian(vec2 _curPix, float _borderThickness)
{
	// If any of these step calls return 0, then _curPix is within a border.
	float retVal = step(_borderThickness, _curPix.x) * step(_borderThickness, _curPix.y) * step(_curPix.x, 1.0 - _borderThickness) * step(_curPix.y, 1.0 - _borderThickness);
	return retVal;
}

//-----------------------------------------------

float dot2( in vec2 v ) { return dot(v,v); }
float maxcomp( in vec2 v ) { return max(v.x,v.y); }

// Alternative to OpenGL's built-in normalize which checks for zero vectors.
vec2 normalizeSafe(in vec2 v)
{
	float len = length(v);
	vec2 normal = (len == 0.0) ? vec2(0.0, 1.0) : v / len;
	return normal;
}

// Take a point in the unit square [-1,1]^2 and map it
// into a point in the unit disk
vec2 square2circle( in vec2 v )
{
    #if IMPROVED==0
    return maxcomp(abs(v))*normalizeSafe(v);
    #else
    return maxcomp(abs(v))*normalizeSafe(v*(2.0+abs(v)));
    #endif
}

vec2 circle2square( vec2 v )
{
    #if IMPROVED==0
    return v*length(v)/maxcomp(abs(v));
    #else
    return vec2(0.0);
    #endif
}

//-----------------------------------------------

float sdLineSq( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
	return dot2(pa-ba*h);
}

float sdPointSq( in vec2 p, in vec2 a )
{
    return dot2(p-a);
}

//-----------------------------------------------

vec2 vertex( int i, int j, int num, float anim)
{
    // unit square
    vec2 s = -1.0+2.0*vec2(i,j)/float(num);
    
    // unit circle
    vec2 c = square2circle(s);
        
    // blend
    return mix(c,s,anim);
}

void main()
{
	// The currently concerned pixel of the texture on which this shader is acting.
	vec2 curPix = gl_TexCoord[0].xy;
	// The coordinates for the center of the tile set.
	vec2 center = vec2(0.5, 0.5);
	// The distance from curPix to center.
	float centerDistance = length(center.xy - curPix);
	// The default color.
	vec3 color = vec3(0.0);
	
	// plane coords
	vec2 p = (2.0*curPix-1.0);
	float w = 2.0;
	
	// scale
	//p *= 1.15;
	//w *= 1.15;
 
	// anim
	float anim = smoothstep(-0.6,0.6,cos(iTime*2.0+0.0));
	anim = Cartesian == 1 ? smoothstep(0.0, 1.0, TimeSpentShifting / TimeToShift) : 1.0 - smoothstep(0.0, 1.0, TimeSpentShifting / TimeToShift);
	float show = smoothstep(-0.1,0.1,sin(iTime*1.0+3.4));
	
	// mesh: body
	vec2 di = vec2(10.0);
	int num = int(Square);
	for( int j=0; j<num; j++ )
	{
		for( int i=0; i<num; i++ )
		{
			vec2 a = vertex(i+0,j+0,num,anim);
			vec2 b = vertex(i+1,j+0,num,anim);
			vec2 c = vertex(i+0,j+1,num,anim);
			di = min( di, vec2(min(sdLineSq(p,a,b), 
								   sdLineSq(p,a,c)),
								   sdPointSq(p,a)));
		}
	}
	// mesh: top and right edges
	for( int j=0; j<num; j++ )
	{
		vec2 a = vertex(num,j+0,num,anim);
		vec2 b = vertex(num,j+1,num,anim);
		vec2 c = vertex(j+0,num,num,anim);
		vec2 d = vertex(j+1,num,num,anim);
		di = min( di, vec2(min(sdLineSq(p,a,b), 
							   sdLineSq(p,c,d)),
						   min(sdPointSq(p,a),
							   sdPointSq(p,c))));
	}
	// mesh: top-right corner
	di.y = min( di.y, sdPointSq(p,vertex(num,num,num,anim)));
	di = sqrt(di);

	
	// background
	vec3 col = vec3(1.0);
	
	// colorize displacement
	vec2 q = square2circle(p);
	//vec2 p1 = mix(q,p,    anim);
	vec2 p2 = mix(q,p,1.0-anim);
	//col = mix( col, 0.6 + 0.5*cos(length(p-p1)*15.0 + 2.5+vec3(0,2,4)),
			   //show*smoothstep(0.999,0.99,length(p2)) );
	// draw mesh    
	//col *= 0.9+0.1*smoothstep(0.0,0.05,di.x);
	//col *= smoothstep(0.0,0.008,di.x);
	// Within radius.
	col *= (1.0 - step(0.0,di.x) * step(di.x,0.008));
	// Outside radius.
	col *= step(length(p2) + 0.011, 0.999);
	// Draw vertices.
	//col *= smoothstep(0.03,0.03+w,di.y );
	
	// vignette
	//col *= 1.0 - 0.15*length(p);

	// output
	gl_FragColor = vec4(col, 1.0);
}"

[E-TileSetState]
Cartesian1D = 0
Cartesian2D = 1
Polar1D = 2
Polar2D = 3

[E-TileSetShiftStatus]
None = 0
D1 = 1
D2 = 2
Cartesian = 3
Polar = 4
D1Tiles = 5